**Задача:** Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

Примеры: [“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”] [“1234”, “1567”, “-2”, “computer science”] → [“-2”] [“Russia”, “Denmark”, “Kazan”] → []

## Решение:
1. Выводим запрос на ввод количества элементов массива (_size_).
2. Пользователь заполняет массив с клавиатуры.
3. Задаем массив _array1_ размером _size_.
4. С помощью цикла _for_ и введенных пользователем данных заполняется каждый элемент массива _array1_.
5. Вводим переменную _count_ (счетчик элементов подходящих под условие).
6. Вводим переменную _maxSymbols_ (максимально допустимое количество символов в элементе). По условию _maxSymbols = 3_.
7. В следующем цикле вводим элементы массива начиная с первого _array1[0]_, до тех пор, пока _индекс [i]_ меньше длины массива _size_, прибавляя по одному.
8. Каждый элемент массива проверяем по условию: длинна элемента _array[i] <= maxSymbols_. Если условие соблюдено, увеличиваем _count_ на один. Если нет - переходим к проверке следующего элемента массива _array1[i+1]_.
9. Задаем переменную _j=0_ .Заполняем новый массив _array2_ в пределах цикла. Для этого повторно проводим проверку каждого элемента массива, чтобы длина элемента _array1[i]_ была больше или равна _maxSymbols_. Если условие соблюдено, элементу _array2[j]_ присваиваем соответствующее значение элемента _array1[i]_. Записываем его в массив _array2_. Если нет, переходим к проверке следующего элемента _array1[i+1]_.
10. Выводим массив _array1_ и полученный массив _array2_ на экран.